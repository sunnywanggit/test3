(window.webpackJsonp=window.webpackJsonp||[]).push([[86],{495:function(t,s,n){"use strict";n.r(s);var a=n(30),e=Object(a.a)({},(function(){var t=this,s=t.$createElement,n=t._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("p",[t._v("在说区别之前，首先需要明白一个概念，就是"),n("strong",[t._v("变量提升")]),t._v("。")]),t._v(" "),n("p",[t._v("所谓变量提升，就是我们可以在一个变量还没有被声明之前去使用它，这种情况就叫做变量提升，并且提升的是声明。")]),t._v(" "),n("p",[t._v("不仅变量会提升，函数也会被提升，并且优先于变量提升。")]),t._v(" "),n("p",[n("strong",[t._v("var")])]),t._v(" "),n("p",[t._v("var 就存在变量提升，使用 var 声明的变量会被提升到作用域的顶部。")]),t._v(" "),n("p",[t._v("为什么会存在变量提升？")]),t._v(" "),n("p",[t._v("其实提升存在的根本原因就是为了解决函数间互相调用的情况。")]),t._v(" "),n("div",{staticClass:"language-js line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("test1")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("test2")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("test2")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("test1")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("test1")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br"),n("span",{staticClass:"line-number"},[t._v("3")]),n("br"),n("span",{staticClass:"line-number"},[t._v("4")]),n("br"),n("span",{staticClass:"line-number"},[t._v("5")]),n("br"),n("span",{staticClass:"line-number"},[t._v("6")]),n("br"),n("span",{staticClass:"line-number"},[t._v("7")]),n("br")])]),n("p",[t._v("假如不存在提升这个情况，那么就实现不了上述的代码，因为不可能存在 test1 在 test2 前面然后 test2 又在 test1 前面。")]),t._v(" "),n("p",[n("strong",[t._v("let")])]),t._v(" "),n("p",[t._v("使用 let 来声明变量，不存在变量提升的问题，但是会出现暂时性死区。")]),t._v(" "),n("p",[t._v("所谓暂时性死区，就是在使用 let 声明一个变量之前无法访问这个变量，这就叫暂时性死区。")]),t._v(" "),n("p",[n("strong",[t._v("总结：")])]),t._v(" "),n("ul",[n("li",[t._v("var存在变量提升，同时存在函数提升。（函数提升优先于变量提升，函数提升会把整个函数挪到作用域顶部，变量提升只会把声明挪到作用域顶部）。let、const 因为暂时性死区的原因，不能在声明前使用")]),t._v(" "),n("li",[t._v("var 在全局作用域下声明变量会导致变量挂载在 window 上，其他两者不会")]),t._v(" "),n("li",[t._v("let 和 const 作用基本一致，但是后者声明的变量不能再次赋值")])])])}),[],!1,null,null,null);s.default=e.exports}}]);